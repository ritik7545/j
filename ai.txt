Hinoai tower
def moveTower(n, fromPole , toPole, withPole):
    if n:
        moveTower(n-1,fromPole,withPole,toPole)
        print(f" move tower from: {fromPole} to {toPole}")
        moveTower(n-1,withPole,toPole,fromPole)
moveTower(3,"A","B","C")
----------------------------------------------------------------------------------
deapth first search
#dfs
graphs1 ={
    'A':set(['B','C']),
    'B':set(['A','D','E']),
    'C':set(['A','F']),
    'D':set(['B']),
    'E':set(['B']),
    'F':set(['C']),
    }
def dfs(graph, node,visited):
    if node not in visited:
        visited.append(node)
        for n in graph[node]:
            dfs(graph, n , visited)
    return (visited)

visited=dfs(graphs1,"A",[])
print(visited)
--------------------------------------------------------------------------------
card shuffle 
import random

suits=["Hearts","Diamonds","clubs","spades"]

cardfaces =[str(i) for i in range(2,11)]+ ["J","Q","A","K"]

deck=[f"{face} of {suit}" for suit in suits for face in cardfaces]

random.shuffle(deck)
print("\n".join(deck))
--------------------------------------------------------------------------------
bearth first search 
#bfs

graphs1 ={
    'A':set(['B','C']),
    'B':set(['A','D','E']),
    'C':set(['A','F']),
    'D':set(['B']),
    'E':set(['B']),
    'F':set(['C']),
    }
visited =[]
queue =[]
def bfs(visited, graph, node):
    visited.append(node)
    queue.append(node)

    while queue:
        m=queue.pop(0)
        print(m,end="")
        for n in graph[m]:
            if n not in visited:
                visited.append(n)
                queue.append(n)

bfs(visited,graphs1,"A")
----------------------------------------------------------------------------

A* algorithm
from simpleai.search import SearchProblem , astar
GOAL = "HELLO WORLD"
class HelloProblem(SearchProblem):
    def actions(self,state):
        return list(' ABCDEFGHIJKLMNOPQRSTUVWXYZ ')if len(state)<len(GOAL) else[]

    def result (self,state,action):
        return state + action

    def is_goal(self,state):
        return state == GOAL

    def heuristic(self,state):
        return sum(1 for i in range(len(state)) if state[i]!= GOAL[i]) + (len(GOAL)-len(state))
result= astar(HelloProblem (initial_state=''))
print(result.state)
print(result.path())
------------------------------------------------------------------------------------------------------
facts = {
'Sachin': 'batsman',
'batsman': 'cricketer'
}

def derive_fact(starting_subject, target_predicate):
    current_subject = starting_subject
    while current_subject in facts:
        current_subject = facts[current_subject]
    if current_subject == target_predicate:
        return f"{starting_subject} is {target_predicate}"
    return "Cannot derive the fact"

starting_subject = 'Sachin'
target_predicate = 'cricketer'

result = derive_fact(starting_subject, target_predicate)
print(result)

# a=starting_subject   b= target_predicate c=currnet_subject
-----------------------------------------------------------------------
def associative_law_add(a,b,c):
    num1 = a+(b+c)
    num2 = (a+b)+c
    return num1 , num2

def associative_law_multi(a,b,c):
    num1 = a*(b*c)
    num2 = (a*b)*c
    return num1 , num2

a=2
b=3
c=4

a , b = associative_law_add(a,b,c)
print(f"Associative Law of Addition:")
print(f"Addition is: a+(b+c)= {a} and (a+b)+c= {b}")
print(f"Result: {'Equal' if a == b else 'Not Equal'}")

m , n = associative_law_multi(a,b,c)
print(f"Associative Law of Multiplication:")
print(f"Multiplication is: a+(b+c)= {m} and (a+b)+c= {n}")
print(f"Result: {'Equal' if m == n else 'Not Equal'}")
---------------------------------------------------------------------------
def associative_law_multi(a,b,c):
    num1 = a*(b+c)
    num2 = (a*b)+(a*c)
    return num1 , num2

a=3
b=4
c=5

a , b = associative_law_add(a,b,c)
print(f"Associative Law of Addition:")
print(f"Distributive Law: a*(b+c)= {a} and (a*b)+(a*c)= {b}")

if a==b:
    print("The Distributive Law holds true.")
else:
    print("The Distributive Law does not holds true")











